"""
file_filters.py - File filtering and exclusion logic
"""
import re
from pathlib import Path
from typing import List, Set


class FileFilters:
    """Handle file filtering and exclusion"""
    
    def __init__(self, repo_path: Path):
        self.repo_path = repo_path
        
        # Hard exclude patterns
        self.exclude_dirs = {
            'node_modules', 'venv', 'env', '.env', 'vendor', 'target', 
            'build', 'dist', '.next', '__pycache__', '.pytest_cache',
            '.git', '.vscode', '.idea', '.vs', 'bower_components',
            'packages', '.nuxt', 'out', 'coverage', '.cache', '.venv',
            'site-packages', 'lib', 'lib64', 'include', 'Scripts', 'bin',
            '.tox', '.eggs', '*.egg-info', 'htmlcov', '.mypy_cache',
            '.ruff_cache', '.pytest_cache', '__pypackages__', 'wheels'
        }
        
        self.exclude_files = {
            'package-lock.json', 'yarn.lock', 'Gemfile.lock', 
            'poetry.lock', 'composer.lock', 'Pipfile.lock',
            'pnpm-lock.yaml', 'Cargo.lock'
        }
        
        self.binary_extensions = {
            '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.webp',
            '.woff', '.woff2', '.ttf', '.eot', '.otf',
            '.pdf', '.zip', '.tar', '.gz', '.rar', '.7z',
            '.mp4', '.mp3', '.wav', '.avi', '.mov',
            '.exe', '.dll', '.so', '.dylib', '.bin', '.class'
        }
        
        # Code extensions for parsing
        self.code_extensions = {
            '.py', '.js', '.jsx', '.ts', '.tsx', '.java', '.cpp', 
            '.c', '.h', '.hpp', '.go', '.rs', '.rb', '.php', 
            '.cs', '.swift', '.kt', '.kts', '.scala', '.m', '.mm',
            '.vue', '.svelte', '.dart', '.r', '.lua', '.pl', '.sh',
            '.html', '.htm', '.css', '.scss', '.sass', '.less'
        }
        
        self.config_extensions = {
            '.json', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf'
        }
        
        # Compiled regex for generated markers
        self.generated_pattern = re.compile(
            r'auto-?generated|do not edit|do not modify|generated by|code generated|@generated',
            re.IGNORECASE
        )
        
        self.gitignore_regex = None
        self._load_gitignore()
    
    def _load_gitignore(self):
        """Parse .gitignore and compile patterns"""
        patterns = []
        gitignore_path = self.repo_path / '.gitignore'
        
        if gitignore_path.exists():
            try:
                with open(gitignore_path, 'r', encoding='utf-8', errors='ignore') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            patterns.append(line)
            except:
                pass
        
        # Add common patterns
        patterns.extend([
            'node_modules/', '*.pyc', '__pycache__/', 'venv/', '.venv/',
            '.env', 'build/', 'dist/', '.DS_Store', '*.egg-info/'
        ])
        
        self._compile_gitignore_patterns(patterns)
    
    def _compile_gitignore_patterns(self, patterns: List[str]):
        """Compile gitignore patterns into regex"""
        if not patterns:
            self.gitignore_regex = None
            return
        
        regex_patterns = []
        for pattern in patterns:
            if pattern.endswith('/'):
                regex_patterns.append(re.escape(pattern.rstrip('/')) + r'(/|$)')
            else:
                regex_pattern = pattern.replace('.', r'\.')
                regex_pattern = regex_pattern.replace('*', '.*')
                regex_pattern = regex_pattern.replace('?', '.')
                regex_patterns.append(regex_pattern)
        
        combined = '|'.join(f'({p})' for p in regex_patterns)
        self.gitignore_regex = re.compile(combined)
    
    def matches_gitignore(self, file_path: str) -> bool:
        """Check if file matches gitignore patterns"""
        if self.gitignore_regex is None:
            return False
        return self.gitignore_regex.search(file_path) is not None
    
    def should_exclude_path(self, path_str: str) -> bool:
        """Fast path exclusion check"""
        path_lower = path_str.lower()
        exclude_substrings = [
            'node_modules', 'venv', '__pycache__', 'site-packages', 
            '.egg-info', '/build/', '/dist/', '/.next/'
        ]
        return any(sub in path_lower for sub in exclude_substrings)
    
    def is_generated_file(self, file_path: Path) -> bool:
        """Check if file is auto-generated"""
        path_str = str(file_path).lower()
        
        # Path-based check (instant)
        if any(pattern in path_str for pattern in [
            '/migrations/', '/__generated__/', '/generated/', 
            '/.next/', '.pb.py', '.pb.go', '.generated.', '_pb2.py'
        ]):
            return True
        
        # Content check - only first 5 lines
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = ''.join(next(f, '') for _ in range(5))
                return self.generated_pattern.search(content) is not None
        except:
            return False
    
    def is_binary(self, file_path: Path) -> bool:
        """Check if file is binary"""
        return file_path.suffix in self.binary_extensions
    
    def is_code_file(self, file_path: Path) -> bool:
        """Check if file is a code file"""
        return file_path.suffix in self.code_extensions
    
    def is_config_file(self, file_path: Path) -> bool:
        """Check if file is a config file"""
        return file_path.suffix in self.config_extensions
    
    def is_excluded_file(self, file_path: Path) -> bool:
        """Check if file should be excluded by name"""
        return file_path.name in self.exclude_files
    
    def filter_files(self, files: List[Path]) -> List[Path]:
        """Filter files based on all criteria"""
        filtered = []
        
        for file_path in files:
            # Skip if excluded by name
            if self.is_excluded_file(file_path):
                continue
            
            # Skip if binary
            if self.is_binary(file_path):
                continue
            
            # Skip if not code or config
            if not (self.is_code_file(file_path) or self.is_config_file(file_path)):
                continue
            
            # Skip if matches exclusion patterns
            if self.should_exclude_path(str(file_path)):
                continue
            
            filtered.append(file_path)
        
        return filtered